[ { "title": "2023年度总结", "url": "/posts/2023%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/", "categories": "annual-summary", "tags": "", "date": "2023-01-01 00:00:00 +0800", "snippet": "今年对我来说 感觉时间过得很快之前在21写过一篇总结 本来打算从那时候开始坚持写 但因为一些变数 还是跳过了2022年之前也有想过补上22年的总结 但由于带娃以及一些工作的变动 导致那段时间不是很有空而且补起的总结是否也不再那么应景 挣扎过后还是放弃了关于工作关于工作，其实在22年8月换过一次工作，半远程的形式还算比较满意。但年初时，还算满意的新工作又突遭变故。在3月份时，由于融资的原因，对团队进行了解散。机缘巧合下，我又找了份remote的工作。似乎狠狠地打了自己的脸，因为之前才写过一篇拒绝远程的博文。但这个决定在这个时间点似乎又顺理成章。主要是自己的心态和对未来的预期随着周围环境的变化也起了一些变化。在经济下行的环境中，没有多少家公司能够独善其身，就连原来现金流充沛的互联网巨头们也是连着裁员了几年。从而，国内的环境从本来就很卷到越来越卷。再加上马上35岁的到来，促使我思考什么样的发展才能长远些。目前我给自己的答案是增加国际竞争力，将自己放到国际市场上去1。这样，相对于国内市场，会有更好的性价比。而当前能够将自己放到国际市场上的方式来说，似乎remote是唯一的选择。另外，高性价比的工作机会也会有更多的个人时间，可以用来陪家人以及可能做出一个独立产品，从而促成一条更长远的路。2这一年跌跌撞撞，但也谢天谢地，希望来年有更好的收获关于经济今年一整年都在美国加息的进程中，美元和美债收益率一路攀升，中国的经济却萎靡不振。原本疫情期间”胜负”似乎在很短的时间里完全颠倒了过来，确实有些魔幻。美元的持续加息导致全球资产承压，所有行业都变得保守。猜测这也和年初的公司融资失败多少有一点点关系。中概互联网从我21年底总结提到后，还是在最低位震荡走低，属实有点难。今年除了中国外，其他大国基本上都是疫情大放水后，开始加息压制通胀。中国的周期完全相反了。今年的股市也是只有中国和香港负增长，着实有点讽刺。关于AI今年是AI爆火的一年。各种类型的AI模型横空出世，造就了很多新的机遇和机会。今年在这个方面投入的注意力还不够，还是得多学习下，尽量跟上这个发展。但大部分的成熟AI还是在美国，且不对中国开发，有点难。关于2024关于新的一年，我还是有一些愿望，或者说想要做成的事情： 孩子明年2岁了，希望后面开始每年能够去一次国外旅游，去一次国内旅游 办一张香港卡，创造更多的机会和可能 考一次雅思，取的好成绩 尽量每个月读一本书(这个可能比较难达成…) 今年的remote工作也是海外企业，而且需要全英文交流。这也是我决定选择的一个重要原因。相信多少可以打开一些国际化的大门。当然报酬的性价比也不低 &amp;#8617; 今年也关注到twitter上有很多build in public的个人开发者，由于AI的赋能和崛起，抓住了不错的机会。 &amp;#8617; " }, { "title": "如何判断当前的经济情况", "url": "/posts/how-to-know-the-trending-of-economy/", "categories": "investment", "tags": "", "date": "2022-04-23 00:00:00 +0800", "snippet": "如何判断当前的经济情况为什么要了解当前的经济情况?当前的经济处于什么趋势当中，未来的经济会如何走？这看起来像是专业人士会比较关心的问题。但又似乎和很多事情都有着联系。经济走势和二级市场的走势息息相关经济走势和就业失业情况密切相关经济走势和你的房贷利率有着联系…去年到今年比较大的错就是忽略了经济走势的关注。以及上海疫情对整体投资环境所造成的影响1。简单总结下可以反映当前经济走势的几个重要指标。存款准备金率存款准备金 是指国家规定的，为了应对系统风险，让银行预留的准备金以往新闻中说到的降准就是指降低准备金率降低准备金率，就意味着银行需预留的准备金减少，也就意味着社会中流动的钱会增加所以一般来说降准是提振经济的手段，预示着宽松的货币政策PMI (采购经理人指数)PMI 表示企业采购的信心和动向，可以看出企业在采购方面的投入，也就预示着企业对社会经济发展的信心如果企业对经济不看好，则会减少投入，传导到下游，就会对经济产生负面影响PPI (工业品出厂价格指数)PPI 可以理解为企业的出厂价格变化指标，影响PPI的因素可能为原材料成本涨价，通货膨胀等CPI (居民消费价格指数)CPI 可以大致看为商品零售价格变化指标。CPI 一般用来表示消费者消费意愿，结合PPI可以看出经济的健康情况。如果发送倒挂，则是需要警惕的信号，理论上这种现象不应该维持长时间。外商直接投资数据(FDI)FDI社会消费品零售总额社会消费品零售总额投资者人数投资者人数 可以看出当前人民对市场的信息和狂热程度。例如2015年的高峰，账户数则达到400多w户货币供应量货币供应量 可以反映出货币宽松情况，是放水还是收缩 美国的加息叠加上上海的封城让外资对中国的投资非常保守，导致如何不管是投资机构还是互联网企业都非常艰难。 &amp;#8617; " }, { "title": "The Precious Links", "url": "/posts/the-precious-links/", "categories": "summary", "tags": "", "date": "2022-02-08 00:00:00 +0800", "snippet": "PrefaceThis article records the web links which I think is valuable and worth a look.TechThe recent change of Martin FowlerRaft algorithmBusinessPaul Graham’s ArticleSam AltmanReid Hoffman" }, { "title": "2021年终总结", "url": "/posts/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/", "categories": "annual-summary", "tags": "", "date": "2022-02-03 00:00:00 +0800", "snippet": "今年打算开始写年终总结会有几个原因 看到一个很厉害的前辈一直有写年终总结的习惯，是一种非常好的自省和总结的方式。如果你希望自己能够越来越好，得先从自省和反思开始 今年发生了很多事，经历了很多，困惑过，迷茫过 发现了觉得最好看，功能最全面的很棒的博客主题，觉得不能辜负她到现在，新冠疫情 已经持续了2年有余，而尚未能明确看到能够结束的时期。从最初形态的新冠病毒，到Delta，再到Omicron，似乎新冠病毒也学会敏捷和迭代，以至于演进的这么快速，让世界各地的专家和政客这么头疼当然最难受的还是商家。这两年一直持续的关店潮，以及各种小酒店和民宿的易主都在说明这些而2021年的互联网也并不好受中概互联ETF从年初的高点一路下跌，跌去了50%由于年初国家开始管控在线教育/教培企业，所有在去年还蓬勃发展的在线教育突然就失去了资本的宠爱。好未来从$70左右迭到了现在的$2.96，高途从最高的$100多跌到现在的$1.83，新东方也从年初的$18多迭到了现在的$1.38。2021年对无数教培行业的工作人员来说会是个艰难的时刻。相信这样的结局很少有人能够真正预测得到而我所工作的公司也受到了很大的影响，好在通过公司高层的策略调整，在年末时还获得了一些不错的成绩1。但在过程中的阵痛还历历在目，公司业绩下滑，大裁员，团队人心涣散，高层外走…在这样的剧变大环境中，自然我本身也经历了很多内心的起伏在团队不够凝聚时，会重新思考，当企业失去高成长的向心力时，还能够凝聚团队的因素会是什么做技术的，管理能力到底有多重要2？管理到底是干什么的？怎么样的团队才算是好的团队？如何建立自己的Reputation?因为公司转型Java不久，也因为之前管理工作较繁重，我一直认为我还没有完全理解和掌握好Java生态的知识。当我放弃了远程工作机会后，我开始投入Java相关的知识学习，总算感觉掌握了一些必要的知识和能力。今年也和自己团队中”仅存”的两位小伙伴一起结成了学习小分队，对一些之前不扎实的知识点进行了巩固补充，感受很好切身地感受到：当你真正了解事物内部运行的原理，真的可以帮助你“用好”它。当然，好处不止于此同时，也从CEO和朋友的推荐中获得了很多好书，希望新的一年能够读完，补充更多的除技术外的底层逻辑和商业的知识现在感觉自己的读书方法和效率有点问题，就选择先读Mortimer Adler的《How to Read a Book》，还是收获很多。不同的书，不同的部分，应该用不同的速率去读。新的一年，还有一件非常非常激动和重要的事情即将发生 - 我将成为一名父亲。自然，多了一个身份，也会多一份责任，希望他能够健康平安地成长。最后，期待自己在新的一年，能够拥有更多的创造力，追求自己所追求的。Best wishes!Footnote 要管理好一家公司真的很不容易，看到Shawn将被动扭转为主动，开始投入社区业务，并在过程中不断调整策略，到当前的a16z战略，还是很佩服的。 &amp;#8617; 毕竟技术面试大部分面的还是技术。只要你做的是研发的工作，不管你的管理和综合能力如何，只要是技术面试，技术是跑不掉的。Java等语言的八股文组合拳就更别说了。 &amp;#8617; " }, { "title": "社区推荐系统", "url": "/posts/%E7%A4%BE%E5%8C%BA%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/", "categories": "work", "tags": "", "date": "2021-09-18 00:00:00 +0800", "snippet": "目的推荐系统是内容类网站不可或缺的组成部分。而推荐系统的最终目的总结起来就是: 能够通过精确地给用户推荐内容，来提升用户留存率和活跃（目前新用户次日留存率平均22%） 有能力高效地将运营内容推送给目标用户问题推荐系统最主要的问题是两点: 推荐效率 推荐准确度每个系统中可能都会存在不同的用户特征数据，可能是属性数据，也可能是行为数据，但往往这种用户特征数据的数据量是比较庞大的。对这些大量特征数据进行快速的分析和处理就是推荐效率的难题所在。而正确的选择用户特征数据，提取方式和判断方式是推荐准确度的难题所在。处理流程由于要处理的数据量较为庞大，业界对推荐系统的处理流程大都是以下流程: flowchart LR A(输入) --&amp;gt;|万/百万/亿| B(召回) B --&amp;gt; |千/万| C(排序) C --&amp;gt; |百/千| D(调整) D --&amp;gt; |十/百| E(输出)召回召回最初步的过滤也是最重要的筛选环节，召回就是会通过特征数据对内容进行合理的筛选，使大量的数据会在这个环节被匹配过滤掉。我的理解是这个环节会更关注通用的内容特征和用户行为数据表达的特征。召回的方式一般都可以总结为内容与内容，人与人之间的练习。进一步可以归纳为以下几种 召回方式 说明 例子 i2i 通过内容推荐内容 给用户推荐相同话题下的内容 u2i 通过用户行为推荐内容 用户玩过了《愤怒小鸟》，还会给他推荐 《愤怒小鸟》 u2i2i 通过用户行为推荐相似内容 用户玩过了《愤怒小鸟》，还会给他推荐 《愤怒小鸟》其他系列作品，或游戏作品 u2u2i 通过用户的相似用户推荐内容 用户A和B是相似用户或朋友，会推荐用户B喜欢的内容给用户A u2tag2i 计算出用户和内容的标签，通过标签匹配 用户A喜欢奥特曼，内容a是奥特曼主题，推荐内容a给用户A Tips: u表示user，i表示item排序接收召回的输出，再通过用户更细节的数据，来判断用户的喜好，对内容数据进行排序，进一步选择出合适的内容。我的理解是这一步会加入更多用户个性化属性特征数据调整对排序的输出再进行数据调整和补齐，例如去重，业务数据补全，推荐数据不全，最终输出给用户系统架构要做好推荐系统，涉及到的知识和系统非常多，需要涉及大数据的处理，机器学习对推荐模型的训练，数据高效响应的缓存设计等等。推荐系统可以按模块被划分为3个部分： 基础数据 推荐模型 线上服务在架构上，Netflix在博客上讲述了它所使用的大致架构设计，我们可以借鉴。Netflix推荐系统架构Netflix在System Architectures for Personalization and Recommendation中有介绍过其使用的推荐系统架构，如下图核心是因为推荐系统所需要的数据处理和分析过程较复杂，难度较大，所以将数据分为三个层次进行处理： offline: 用来处理数据量较大，耗时较长，无需及时响应的数据，并将处理结果进行存储。 nearline: 用来处理耗时不会太长，无需及时响应的数据。 online: 用来计算耗时极短的计算，基本上就是做实时推荐。需要有降级方案，避免计算时间过长。一期落地方案由于推荐系统比较复杂，需要分期进行实现，且我们当前用户数据和内容数据的丰富度也没有那么高。所以我们第一期，先实现简单的基础功能。可用特征分析用户 flowchart LR A(用户) --&amp;gt; B(年龄) A --&amp;gt; C(性别) A --&amp;gt; D(关注人关系) A --&amp;gt; E(编程能力)作品graph LR A(作品) --&amp;gt; B(作品类型) A --&amp;gt; C(星球标签) A --&amp;gt; D(作品评级)行为graph LR A(行为) --&amp;gt; B(点赞) A --&amp;gt; C(收藏) A --&amp;gt; D(打赏) A --&amp;gt; E(浏览)可以online计算的部分 用户: 年龄，性别，编程能力 作品: 作品类型，星球标签，作品评级需要nearline或offline计算的部分 用户: 关注人关系的相关性计算 行为: 所有的行为分析计算如何简化按照之前说的，推荐系统极其复杂，所以我们需要进行分期实现，第一期会是一个简化的版本。推荐系统中最复杂的部分以及开发周期较长的部分就是大数据处理和人工智能模型训练的部分。因此，第一期我们就去掉这两大块部分。简化的架构如下图所示：graph TD A(行为数据) --&amp;gt; D(nearline计算) B(内容属性数据) --&amp;gt; D(nearline计算) C(用户属性数据) --&amp;gt; D(nearline计算) B --&amp;gt; G C --&amp;gt; G D --&amp;gt; E(Cache) D --&amp;gt; F(Mysql/Mongo) E --&amp;gt; G(召回计算) F --&amp;gt; G G --&amp;gt; H(排序/调整/过滤) H --&amp;gt; I(客户端) I --&amp;gt; A召回计算规则根据Netflix的描述，在召回规则中，热度值和新鲜度也会是一个非常重要的元素。与产品沟通后补充AB测试设计推荐系统另一个重要的部分就是验证推荐策略的有效性，所以AB测试是推荐系统不可或缺的部分。待补充" }, { "title": "数据结构的联系与使用", "url": "/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E4%BD%BF%E7%94%A8/", "categories": "programming", "tags": "", "date": "2021-09-13 00:00:00 +0800", "snippet": "前言作为程序员，基础数据结构是我们在日常工作中必须掌握的基础知识，就像是建房子时的图纸，而熟练地掌握数据结构可以让我们在工作中能够以更加高效和巧妙的方式来解决所遇到的问题。然而，没有一个数据结构是完美的，每一个数据结构都是优点和缺点并存，就如同世间万物，总是有正反或阴阳两面。每一个数据结构都是计算机科学家们为了解决某一个问题而发明的，并没有好坏之分，只是在具体的场景下，会有更适合的应用。因此，随着计算机科学的发展，就产生了非常多的数据结构。这里我尝试由浅入深去猜想各种数据结构产生的原因并将它们进行串联，期望能够达到方便记忆的效果。提醒: 以下数据结构演进原因为个人理解和猜想，只是为了串联各种数据结构。基础结构Array查找 O(1)插入/删除 O(n)数组应该是我们日常中使用最多的数据结构，数组是由一个个元素组成，并以下标一一做标记。它的特别非常明确，可以直接通过下标查找或修改元素，因此查找和修改非常高效；但要插入或删除元素时，需要重新排列下标，效率较低。因此数组适合多读少写的场景（这里的写指插入和删除元素）。那肯定要解决插入效率低的场景啊，所以程序员就想到取消下标的方式，将每个元素按顺序串联起来，以串联的顺序来决定元素所在的问题，这也就是LinkedList了。LinkedList查找 O(n)插入/删除 O(1)链表也是由一个一个元素组成，但是以一种串联的形式组成。 链表的元素叫node，下一个node指向上一个node，一直到最前面的node，像是一个链条。如果要在AB两个node中新增一个node，只需B node指向新node，而新node再指向A，就完成了插入，非常高效。但因为缺少下标，它不是很擅长查找的场景，因为没有下标来快速定位，它需要一个一个node地询问，直到找到自己的目标。因此数组适合少读多写的场景。Map查找 O(1)插入 O(1)但程序员肯定会遇到既需要查找快，也需要修改快的场景啊。那这种场景下，Array和LinkedList都不是特别能够满足要求了。于是，程序员就想如何解决这样的问题。程序员先从分析Array下手Array修改低下的原因主要是： 在中间进行元素插入或删除，就需要重排下标 初始大小固定，如果超出，则需要重新分配和迁移元素所以，要解决Array修改效率低的问题就需要 取消下标，用非顺序数字的形式来作为索引，进行查找 不设置固定大小于是程序员就自己实现了新的数据结构来尝试解决这个问题，就有了Map。tips：Java中Map是通过Array实现的，所以其实固定大小的问题在Java中没有被解决。Map是由一个个pairs组成，pairs是由key和value组成。Map的优势就是可通过key快速查找到value的值。也可以高效地插入新的Pair。当然Map也有缺点，Map的索引不是类似有序数字的下标，所以Key是无序的，且作为索引，Key元素不可重复。Tree查找 O(logN)插入 O(logN)于是程序员又想，那能不能从LinkedList入手，尝试去解决LinkedList的缺陷。LinkedList的问题是查找效率。通过顺序查找是比较低效的查找方式，而在元素有序的条件下，最有效率的方式应该就是二分法查找了。二分法的思路有点像算法中的“剪枝”，当路径分叉时，只关注有用的路径。能不能通过二分法查找来提高LinkedList的查找效率呢？程序员受到二分法查找的启发，发明了又一个新的数据结构 - Tree。Array 的衍生Vector(Java和C++中的实现)Vector在理论上的定义就是一维数组。但在Java中的实现会有些特点。众所周知，Array有个限制，就是在初始化时需要给定大小来确定分配的内存大小。程序员写多了Size不够用的Array之后，心想将这个过程抽个方法吧，太累了，后面就演进成了一个新型数据结构Vector，其实就是能够自动扩展的Array了。Java中实现的Vector还有个特点，插入元素时是单线程加锁插入。Stack当程序员经常要写插入元素到数组，然后以倒序输出的场景。他就在想，这块代码是不是也能抽离一下，每次都要记录下标和Size，封装一下应该就通用很多。于是，就有了Stack，一个以First In Last Out闻名的数据结构。其实就是倒序排序了一下。Queue既然有了正序输入倒序输出的场景（Stack），自然少不了正序输入正序输出的场景了，于是程序员也创造了Queue，类似管道或队列，所以Queue的特点就是First In First Out。DeQueue(Double-end Queue)有了Queue之后，程序员又想，要不再做灵活点，方便我从头尾都可以输入，也可以从头尾都可以读取，于是就有了DeQueque。Map的衍生Set程序员偶尔会遇到需要元素唯一的场景，如果有Array来做，我们在收集完元素后，还需要进行一个算法复杂度为O(n)的排除计算。因此期望用一个数据结构来解决这个问题，就叫Set。之前我们说到过Map有个特点是Key元素不可重复，Java程序员发现可以利用Map这个特性，在元素去重的场景做到自然过滤，避免了多余的排除计算，因此Java中，Set的底层是通过Map来做实现的，也叫HashSet。HashMap/HashTableHashMap可以理解为Map的衍生，也可以理解为是其中一种具体的实现。当Map中的元素较多时，如果要去判断某个元素是否存在于Map中，就会遍历N次。所以程序员们就想了个方法来减少Key的数量，来提高这里的效率。通过结合Hash算法，可以控制Pair中Key的冲撞几率，可以用较少的Key储存更多的Value。这个设计就很类似于索引。然而，这样的结果就是Pair中的Value就会存在多个，在Java中是使用LinkedList来存储同一个pair中的多个value的。tips: Java8之后，也对HashMap做了优化，当碰撞的次数大于8并且总容量大于64的时候，储存Value的链表就会变为红黑树结构（这里应该就默认这里变为了需要提高读效率的场景了)。tips2: 在Java中，HashMap和HashTable有个小的区分实现，HashTable的元素插入是会加锁(sychronized)插入的。BloomFilterBloomFilter一般比较少被大家使用，但实际用处还比较大。BloomFilter是一个很长的二进制向量(可以使用BitSet, 也可以使用Map)和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。Tree的衍生Search Tree我们之前有说到，Tree的查找是有受到二分法的启发。二分法可以使用的一个必要条件就是需要元素是有序的。因此，想要Tree的查找应用二分法查找的方式，自然其中的元素也必须是有序的。这种Tree，被命名为Search Tree，其中任何节点都必须比左子树中的节点大，而比右子树上的节点小。BinaryTree那要让二分查找法在Tree中的效率最高，就最好是每个节点下最多有两个子节点，这种类型的Tree我们叫它BinaryTree。所以BinarySearchTree理论上是Tree中搜索速度最快的。BalancedTree(AVL Tree, Treap, Splay Tree, RedBlackTree et al.)Tree的搜索效率还有一个重要的影响因素，就是树的高度。那程序员就想如何才能让树的高度永远处于一个最优的情况呢？其实高度最优的情况就是避免产生极度坏的情况(极度坏的情况其实就类似链表了)，让根节点到每个叶子节点的路径都相等，就避免了最坏查询情况的产生。要想达到该效果，就要在每次新元素加入或移除的时候，对树做一些额外调整，也就产生了自平衡树。Priority Queue &amp;amp; Heap(Max &amp;amp; Min)基于Search Tree的一个拓展，Seach Tree的排序是从左到右的。那程序员有天就想，如果是一个优先取最小值的场景的话，将排序做成垂直的，从小到大排列，那不是第一个就是最小值么，于是做了这样的优化后，就产生了Priority Queue。同理，也适用于从大到小排列的场景。tips: Heap是Priority Queue的一种实现Tree在业务场景中衍生的数据结构Trie利用Tree分叉的结构来做单词搜索，提升搜索效率，产生了新的数据结构Trie。Disjoint-Set/Union Find SetDisjoint-set又叫并查集，一般被用来做分类和区分。Disjoint-set的实现一般是使用类似Tree的结构，利用了Tree每个节点都只会有一个Parent的特性来做分类和合并。当两个节点的root节点一致时，则认为两个节点为一类。GraphTree有一个特点就是每个节点都只能有一个父节点，但现实生活中，肯定会出现需要一个节点有多个父节点的情况，就产生了一个特殊的Tree，一个新的数据结构，被命名为Graph。Graph由vertices和edges组成。B TreeB Tree的场景有点特殊，在数据库设计者在设计索引时，肯定是要符合多写多读的场景的，再加上对顺序的要求，很自然是应该应用Tree。但如果使用上面说到的BinarySearchTree，会产生一个问题。因为数据库的数据最终是要存储在硬盘上的，开发同学可能都知道磁盘查询是个性能较慢的操作，特别是随机查询。要知道Tree的每一个节点都是独立的，所以不可能是连续数据，如果按照BinarySearchTree的方式来做，就会使得树的高度增加，导致查询节点的次数增多，每一个都要做一次磁盘查询，这样总体上性能就会很慢。那为了解决这个问题，数据库的设计者们就想到了一个针对性的优化-减少树的高度，一个节点多存些数据。于是就发明了一种新的Tree的数据结构，命名为B Tree。B+ TreeB+ Tree是B Tree的增强版，是为了优化B树刚好在范围查询时，查找的数据没有在当前节点上，而导致额外查询其他兄弟节点的场景。所以数据库设计者又将B Tree中的兄弟节点都链接起来，加快同级查询，就产生了B+ Tree。既然说到了关系型数据库所使用的B+树，那就顺带讲一下redis中应用的另一种业务场景中衍生的数据结构。LinkedList在业务场景中衍生的数据结构跳表(SkipList)我们之前提到过LinkedList适合多写少读的场景，因为查询效率不高。跳表的发明就是尝试解决LinkedList的这个缺陷的。跳表可以理解为是加了索引的LinkedList。Redis中就是用跳表来实现有序集合的。那Redis为什么不用树来实现呢？我的理解是Redis是基于内存的，所以不用过于考虑硬盘查询的性能消耗，就没有必要使用B+树这样的结构，那最快的查询树就是BinarySearchTree了。但BinarySearchTree在区间范围查询上有个缺陷，也就是为什么B树演进为B+树的原因。因此，就发明了跳表，LinkedList加上索引后，采用的思路也是类似于二分法的思路，也解决了Tree在范围查询上的缺陷，唯独就是理论上会比Tree多占用些空间，以空间换时间。结语希望读过这篇文章的同学都能够理解每一个数据结构产生的原因，并能够熟练地应用。附上我整理的关系图最后推荐这个网站，它将各种数据结构和算法以可视化的形式展示了出来，非常便于理解" }, { "title": "我放弃了曾经所向往的「远程工作」", "url": "/posts/%E6%88%91%E6%94%BE%E5%BC%83%E4%BA%86%E6%9B%BE%E7%BB%8F%E6%89%80%E5%90%91%E5%BE%80%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9C/", "categories": "work", "tags": "", "date": "2021-07-18 00:00:00 +0800", "snippet": "背景最近我得到了一个非常棒的远程工作的机会，公司处于发展上升期，薪资福利非常具有竞争力。而经过了一周多的思想挣扎后，我放弃了这个offer。这个决定甚至可能令一周前的自己不解。所以也想写篇文章来记录一下。向往的远程工作相信从事开发，写作或设计的人都多少听说过远程工作或Remote。这种当下新颖的工作方式总会让第一次听说的人不禁羡慕起来。这种能够让社畜们拥有时间和空间自由的工作方式难道不完美吗？我刚入行不久就转做了Ruby on Rails开发，RoR是一种适合创业小团队快速迭代的利器。可能因为小团队更容易做到远程这个事，所以我也很早就听说了这样一种工作形式。国内比较早实行这种工作形式的，据我了解，应该是Tower（最近也和Tower的人聊过，Tower已经不再是当年的Tower了，还是有些感慨）。远程工作令当时年轻的我艳羡不已，可由于自己当时还不够自信，没有走出迈向心中“殿堂”的第一步。为什么我会向往向往远程工作的原因应该对广大“社畜”来说是显而易见的 当你每天需要挤着挤不上去的地铁，坐上1个小时，甚至更多的时间才能够到达还算舒服的办公室。你肯定恨透了这种你每天必须重复的通勤。 当你想每天抽一点时间让自己学习的时候，发现公司加班或长时间的通勤已经把你的精力消耗殆尽 当你想多陪陪家人的时候，你发现大城市的高房价，家乡的低薪资（甚至无适合工作）都让你绝望 当你刷完朋友圈里朋友的旅行照片后，还是无奈向生活弯了腰而这些当今社会中的普遍问题，远程工作看起来都能够帮你解决，香不香？为什么我会放弃既然这么香，我为什么会放弃?当然，远程工作能解决很多问题，也会带来一些问题，Google上有很多讨论远程工作优缺点的文章。其中，你就可以看到很多远程工作才会产生的问题。而对于我来说，最终让我放弃这样一个不错的远程工作机会的主要原因是 我不想一直做一个一线开发者，哪怕拿着非常有竞争力的薪资 我期望结识更多的伙伴，他们会是我另一种宝贵的财富我不想一直做一个一线开发者，哪怕拿着非常有竞争力的薪资作为一个已经过了30岁的程序员，是否要一直做一线开发者的思考是不可避免的焦虑感。我也会有这样的焦虑感，但更多的是我对自己能力的认识。我自认为沟通能力, 产品意识等综合能力是自己的优势。而选择更注重交付的远程工作，可能会失去自己的优势。且我也不想只做一个“螺丝钉”，我还是期待自己能够和同事“争吵”之后，为所做的产品贡献一点不错的建议。我期望结识更多的伙伴，他们会是我另一种宝贵的财富另一个重要的原因是身边的人。远程工作天然具有隔离属性，你和同事之间的联接和关系不太会“朝夕相处”时那么“亲密”。而这些人在中长期来看，会给你带来很多意想不到的价值。我在当前的公司中，认识了很多人，他们让我非常珍惜，我不想失去这样的机会，包括现在和将来。我的答案可能是人生阶段的不同导致了不同的选择。如果是三四年前的我，肯定毫不犹豫选择远程。而今天的我可能会考虑更多，总结远程工作是向往自由的人都期待的工作方式，可以在当下忙碌的工作中体验自由呼吸的方式，活的更有尊严。然而，这不是无本的买卖，你所需要付出的东西在某种程度上说也是宝贵的。在每一个人生路口做出自己的选择，是非常难的事，却是成长的必经之路。有的选择甚至在不同的时期的自己来看都是难以理解的。" }, { "title": "Principles", "url": "/posts/principles/", "categories": "reading", "tags": "", "date": "2021-01-10 00:00:00 +0800", "snippet": "由于读了Ray Dalio的《原则》，借鉴其中不断记录自己通过犯错和人生体验总结出的原则(principle)的方式，在这里记录自己当前认为比较对的一些原则的总结.work 做对的事，把事情做对 专业的事情交给专业的人做会更加有效 管理做的是乘法算数，要做流程优化，效率优化，全局最优 研发永远解决的是效率和质量的问题，抓住这两个重点investment 交易时永远不要满仓。市场里永远不缺机会，缺的是把握机会的能力 做投资，不要怕利润少，做好防守，相信复利和时间的魔力 谨慎做左侧交易，便宜的股票要发现其跌的原因，以及护城河是否依然存在 配置一些足够好的固收产品" }, { "title": "聊一聊设计模式", "url": "/posts/%E8%81%8A%E4%B8%80%E8%81%8A%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/", "categories": "programming", "tags": "", "date": "2020-11-15 00:00:00 +0800", "snippet": "背景作为程序员，数据结构, 算法和设计模式是经常被提起，且绕不过的三扇大门。对这三项通用技能的掌握可能直接影响你能拿到手的钱。相对来说，数据结构和算法还是比较实际，只要你花时间，不断练习，都不会太差的东西，类似武功中的招数。而设计模式却虚无缥缈很多，类似于武功的心法，需要你自己领悟，只有真正领悟透彻后，它才是你能够使用的利器。那学习设计模式，我们又是在学习什么呢？它能给我们带来什么呢？学习设计模式是为了什么学习设计模式其实本质是在学习如何将我们的代码解耦，且易于后续的扩展。这样，可维护性提高了之后，日后的需求改动所需要的代码改动会有质的差别。毕竟 不变的只有变化 嘛。设计原则和设计模式的关系说到设计模式，我们应该再说说设计原则和设计模式之间的关系。设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。而设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。设计原则和设计模式共同对我们的代码规范和日常代码起着指导性的作用。设计原则设计原则主要包含SOLID原则, KISS原则, YAGNI原则, DRY原则, LOD原则。我们分别来说说代表的意思。SOLID原则SOLID原则包含了多个重要设计原则指的是 SRP - Single Responsibility Principle 单一职责原则 OCP - Open Close Principle 开闭原则 LSP - Liskov Substitution Principle 里氏替换原则 ISP - Interface Segregation Principle 接口隔离原则 DIP - Dependency Inversion Principle 依赖反转原则KISS原则Keep it Simple and StupidYAGNI原则You Ain’t Gonna Need it. 在设计或开发的时候，多思考是否真的需要，避免过度设计。DRY原则Don’t Repeat Yourself 不要写重复的代码。LOD原则Law of Demeter, AKA, The Least Knowledge Principle. 迪米特法则。高内聚、低耦合。底层较通用的类需要尽量不依赖其他类，做好抽象，达到足够的解耦。" }, { "title": "Learning metaprogramming", "url": "/posts/learning-metaprogramming/", "categories": "ruby, programming", "tags": "", "date": "2015-02-01 06:07:20 +0800", "snippet": "Dynamic Patchthe send method could be used to call methods obj.send(:my_method, params)Dynamic Methodthe define_method method could be used to create instance method class Foo do define_method(name) do info = @data_source.send &quot;get_#{name}_info&quot;, @id price = @data_source.send &quot;get_#{name}_price&quot;, @id result = &quot;#{name.capitalize}: #{info} ($#{price})&quot; return &quot;* #{result}&quot; if price &amp;gt;= 100 result end endthe instance_method could be used to call an instance method f = Foo.new f.instance_method(:method_name)Remove Methodthe undef_method method could be used to remove method, it would remove both receiver’s methods and inherited methods undef_method method_namethe remove_method method is similar, but it leaves the inherited methods remove_method method_name" }, { "title": "Ruby: Clean your code!", "url": "/posts/ruby-clean-your-code/", "categories": "programming, ruby", "tags": "", "date": "2014-05-05 00:00:00 +0800", "snippet": "Minimize the number of “nested if statement”“nested if statement” is normally considered as the code smell. We should try to minimize the number of “nested if statement”, though we cannot avoid using it completely.if the ‘if statement’ is embraced by a loop and without ‘else’, use ‘next’ insteadoriginal code: foo.each do |f| if bar if baz ... else ... end end endIt looks not quike clean, isn’t it?cleaned code: foo.each do |f| next if bar if baz ... else ... end endIt looks much better to me.use variable to eliminate the ‘if statement’original code: if bar name = &quot;Jevan&quot; age = 24 else name = &quot;John&quot; age = 24 endcleaned code: user_name = bar ? &quot;Jevan&quot; : &quot;John&quot; name = user_name age = 24" }, { "title": "How to set up the environment of Ruby on Rails", "url": "/posts/how-to-set-up-the-environment-of-ruby-on-rails/", "categories": "ruby, programming", "tags": "", "date": "2014-03-09 06:35:42 +0800", "snippet": "Install RVM and RubyRVM is used to manage different version of ruby. With RVM, you can switch between multiple different version of ruby. To install RVM, simply type the following command in the terminal $ \\curl -sSL https://get.rvm.io | bashor, more convenient, you can just install the RVM with stable ruby by using $ \\curl -sSL https://get.rvm.io | bash -s stable --rubyWhen you finish this step, you can type ruby -vto check if the ruby is available.Install RailsRails is the popular web framework based on ruby. With Ruby installed, you can install all of Rails and its dependencies through RubyGems on the command line: gem install railstype rails -vto check if the rails is available.Here we go! Welcome to the world of Ruby on Rails" } ]
