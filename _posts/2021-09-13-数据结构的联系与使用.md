---
layout: post
title: "数据结构的联系与使用"
date: 2021-09-13
categories: [programming]
---

## 前言

作为程序员，基础数据结构是我们在日常工作中必须掌握的基础知识，就像是建房子时的图纸，而高级的数据结构会让我们在工作中以更加高效和巧妙的方式来解决所遇到的问题。

然而，没有一个数据结构是完美的，每一个数据结构都是优点和缺点并存，就如同世间万物，总是有正反或阴阳两面。

这里我尝试由浅入深去猜想为什么会出现如此多的数据结构，以及他们的产生是为了解决哪一类问题。

## 基础结构
### Array
##### 查找 o(1)
##### 插入/删除 o(n)

数组应该是我们日常中使用最多的数据结构，数组是由一个个元素组成，并以下标一一做标记。它的特别非常明确，可以直接通过下标查找或修改元素，因此查找和修改非常高效；
但要插入或删除元素时，需要重新排列下标，效率较低。因此数组适合`多读少写`的场景（这里的写指插入和删除元素）。

那肯定要解决`多写少读`的场景啊，所以就发明了`LinkedList`来解决这个场景。

### LinkedList
#### 查找 O(n)
#### 插入/删除 O(1)

链表也是由一个一个元素组成，但是以一种串联的形式组成。 链表的元素叫node，下一个node指向上一个node，一直到最前面的node，像是一个链条。如果要在AB两个node中新增一个node，
只需B node指向新node，而新node再指向A，就完成了插入，非常高效。但它不是很擅长查找的场景，因为没有下标来快速定位，它需要一个一个node地询问，直到找到自己的目标。因此数组
适合`少读多写`的场景。

### Map
#### 查找 O(1)
#### 插入 O(1)

而当程序员需要查找快，插入也要快的时候，就发明了Map。
Map是由一个个pairs组成，pairs是由key和value组成。
Map的优势就是可通过key快速查找到value的值。也可以高效地插入新的Pair。
当然Map也有缺点，Map的缺点是元素无序，且Key元素不可重复。

### Tree
#### 查找 O(logN)
#### 插入 O(1)

再过了一阵，当程序员面临的场景是又要插入快，又要读取快，又要有顺序的时候，程序员绞尽脑汁，受到二分法查找的启发，发明了Tree。二分法的思路有点像算法中的“剪枝”，当路径分叉时，只关注有用的路径，Tree也是利用这种思路来提效的。

## Array 的衍生

### Vector(Java和C++中的实现)

众所周知，Array有个限制，就是在初始化时需要给定大小来确定分配的内存大小。程序员写多了Size不够用的Array之后，心想将这个过程抽个方法吧，太累了，后面就演进成了一个新型数据结构Vector，
其实就是能够自动扩展的Array了。

tips: Java中的Vector还有个特点是单线程插入

### Stack

当程序员经常要写插入元素到数组，然后以倒序输出的场景。他就在想，这块代码是不是也能抽离一下，每次都要记录下标和Size，封装一下应该就通用很多。于是，就有了Stack，一个以First In Last Out闻名的数据结构。
其实就是倒序排序了一下。

### Queue

既然有了正序输入倒序输出的场景（Stack），自然少不了正序输入正序输出的场景了，于是程序员也创造了Queue，类似管道或队列，所以Queue的特点就是First In First Out。

### DeQueue(Double-end Queue)

有了Queue之后，程序员又想，要不再做灵活点，方便我从头尾都可以输入，也可以从头尾都可以读取，于是就有了DeQueque。

## Map的衍生

### Set

程序员偶尔会遇到需要元素唯一的场景，如果有Array来做，我们在收集完元素后，还需要进行一个算法复杂度为O(n)的排除计算。因此期望用一个数据结构来解决这个问题，就叫Set。

之前我们说到过Map有个特点是Key元素不可重复，Java程序员发现可以利用Map这个特性，在元素去重的场景做到自然过滤，避免了多余的排除计算，因此Java中，Set的底层是通过Map来做实现的，也叫HashSet。

### HashMap/HashTable

HashMap可以理解为Map的衍生，也可以理解为是其中一种具体的实现。通过结合Hash算法，可以控制Pair中Key的冲撞几率，可以用较少的Key储存更多的Value。然而，这样的结果就是Pair中的Value就会存在多个，在Java中是使用LinkedList来存储同一个pair中的多个value的。

tips: 优化

## Tree的衍生

### Search Tree

我们之前有说到，Tree的查找是有受到二分法的启发。二分法可以使用的一个必要条件就是需要元素是有序的。因此，想要Tree的查找应用二分法查找的方式，自然其中的元素也必须是有序的。
这种Tree，被命名为Search Tree，其中任何节点都必须比左子树中的节点大，而比右子树上的节点小。

### BinaryTree

那要让二分查找法在Tree中的效率最高，就最好是每个节点下都之后两个子节点，这种类型的Tree我们叫它BinaryTree。所以BinarySearchTree理论上是Tree中搜索速度最快的。

### BalancedTree(AVL Tree, Treap, Splay Tree, RedBlackTree et al.)

Tree的搜索效率还有一个重要的影响因素，就是树的高度。
那程序员就想如何才能让树的高度永远处于一个最优的情况呢？
其实高度最优的情况就是避免产生极度坏的情况(极度坏的情况其实就类似链表了)，让根节点到每个叶子节点的路径都相等，就避免了最坏查询情况的产生。
要想达到该效果，就要在每次新元素加入或移除的时候，对树做一些额外调整，也就产生了自平衡树。

### Priority Queue & Heap(Max & Min)
基于Search Tree的一个拓展，Seach Tree的排序是从左到右的。那程序员有天就想，如果是一个优先取最小值的场景的话，将排序做成垂直的，从小到大排列，那不是第一个就是最小值么，于是做了这样的优化后，就产生了Priority Queue。同理，也适用于从大到小排列的场景。

## Tree在业务场景中衍生的数据结构
### Trie
利用Tree分叉的结构来做单词搜索，提升搜索效率，产生了新的数据结构Trie。

### B Tree
self-balancing
more than two children
sorted

### B+ Tree
B tree with linked leaf node

### TreeMap
让Map有序

## 更多高级数据结构

### Graph

### BloomFilter
空间效率和查询时间

### Disjoint-set(Union & Find)
