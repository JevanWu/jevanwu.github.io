---
layout: post
title: "社区推荐系统"
date: 2021-09-18
categories: [system design, work]
---

## 目的

推荐系统是内容类网站不可或缺的组成部分。

而推荐系统的最终目的总结起来就是:
- 能够通过精确地给用户推荐内容，来提升用户留存率和活跃（目前新用户次日留存率平均22%）
- 有能力高效地将运营内容推送给目标用户

## 问题

推荐系统最主要的问题是两点:
- 推荐效率
- 推荐准确度

每个系统中可能都会存在不同的用户特征数据，可能是属性数据，也可能是行为数据，但往往这种用户特征数据的数据量是比较庞大的。
对这些大量特征数据进行快速的分析和处理就是推荐效率的难题所在。而正确的选择用户特征数据，提取方式和判断方式是推荐准确度的难题所在。

## 处理流程

由于要处理的数据量较为庞大，业界对推荐系统的处理流程大都是以下流程:

{% mermaid %}
graph LR
    A(输入) -->|万/百万/亿| B(召回)
    B --> |千/万| C(排序)
    C --> |百/千| D(调整)
    D --> |十/百| E(输出)
{% endmermaid %}

###  召回
召回最初步的过滤也是最重要的筛选环节，召回就是会通过特征数据对内容进行合理的筛选，使大量的数据会在这个环节被匹配过滤掉。我的理解是这个环节会更关注通用的内容特征和用户行为数据表达的特征。

召回的方式一般都可以总结为内容与内容，人与人之间的练习。进一步可以归纳为以下几种

| 召回方式 | 说明 | 例子 |
| --- | --- | --- |
| i2i | 通过内容推荐内容 | 给用户推荐相同话题下的内容 |
| u2i | 通过用户行为推荐内容 | 用户玩过了《愤怒小鸟》，还会给他推荐 《愤怒小鸟》|
| u2i2i | 通过用户行为推荐相似内容 | 用户玩过了《愤怒小鸟》，还会给他推荐 《愤怒小鸟》其他系列作品，或游戏作品 |
| u2u2i | 通过用户的相似用户推荐内容 | 用户A和B是相似用户或朋友，会推荐用户B喜欢的内容给用户A |
| u2tag2i | 计算出用户和内容的标签，通过标签匹配 | 用户A喜欢奥特曼，内容a是奥特曼主题，推荐内容a给用户A |

Tips: u表示user，i表示item

### 排序

接收召回的输出，再通过用户更细节的数据，来判断用户的喜好，对内容数据进行排序，进一步选择出合适的内容。我的理解是这一步会加入更多用户个性化属性特征数据

### 调整

对排序的输出再进行数据调整和补齐，例如去重，业务数据补全，推荐数据不全，最终输出给用户

## 系统架构

要做好推荐系统，涉及到的知识和系统非常多，需要涉及大数据的处理，机器学习对推荐模型的训练，数据高效响应的缓存设计等等。

推荐系统可以按模块被划分为3个部分：
- 基础数据
- 推荐模型
- 线上服务

在架构上，Netflix在博客上讲述了它所使用的大致架构设计，我们可以借鉴。

### Netflix推荐系统架构

Netflix在[System Architectures for Personalization and Recommendation](https://netflixtechblog.com/system-architectures-for-personalization-and-recommendation-e081aa94b5d8)中有介绍过其使用的推荐系统架构，如下图
![image](https://42.dengqinghua.net/assets/images/netflix_framework.png)

核心是因为推荐系统所需要的数据处理和分析过程较复杂，难度较大，所以将数据分为三个层次进行处理：

- `offline`:
    用来处理数据量较大，耗时较长，无需及时响应的数据，并将处理结果进行存储。
- `nearline`:
    用来处理耗时不会太长，无需及时响应的数据。
- `online`:
    用来计算耗时极短的计算，基本上就是做实时推荐。需要有降级方案，避免计算时间过长。

## 一期落地方案

由于推荐系统比较复杂，需要分期进行实现，且我们当前用户数据和内容数据的丰富度也没有那么高。所以我们第一期，先实现简单的基础功能。

### 可用特征分析

#### 用户

{% mermaid %}
graph LR
    A(用户) --> B(年龄)
    A --> C(性别)
    A --> D(关注人关系)
    A --> E(编程能力)
{% endmermaid %}

#### 作品
{% mermaid %}
graph LR
    A(作品) --> B(作品类型)
    A --> C(星球标签)
    A --> D(作品评级)
{% endmermaid %}

#### 行为
{% mermaid %}
graph LR
    A(行为) --> B(点赞)
    A --> C(收藏)
    A --> D(打赏)
    A --> E(浏览)
{% endmermaid %}

#### 可以online计算的部分
 - 用户: 年龄，性别，编程能力
 - 作品: 作品类型，星球标签，作品评级

#### 需要nearline或offline计算的部分
 - 用户: 关注人关系的相关性计算
 - 行为: 所有的行为分析计算

### 如何简化
按照之前说的，推荐系统极其复杂，所以我们需要进行分期实现，第一期会是一个简化的版本。
推荐系统中最复杂的部分以及开发周期较长的部分就是大数据处理和人工智能模型训练的部分。因此，第一期我们就去掉这两大块部分。简化的架构如下图所示：

{% mermaid %}
graph TD
    A(行为数据) --> D(nearline计算)
    B(内容属性数据) --> D(nearline计算)
    C(用户属性数据) --> D(nearline计算)
    B --> G
    C --> G
    D --> E(Cache)
    D --> F(Mysql/Mongo)
    E --> G(召回计算)
    F --> G
    G --> H(排序/调整/过滤)
    H --> I(客户端)
    I --> A
{% endmermaid %}

### 召回计算规则
根据Netflix的描述，在召回规则中，热度值和新鲜度也会是一个非常重要的元素。
与产品沟通后补充

## AB测试设计
推荐系统另一个重要的部分就是验证推荐策略的有效性，所以AB测试是推荐系统不可或缺的部分。待补充
